---
title: '1.5.0 | @uiloos/core | Releases'
layout: layouts/base.njk
permalink: /releases/core/1.5.0/
stickyNavigation: false
description: "Release notes of @uiloos/core 1.5.0"
keywords: "release notes @uiloos/core 1.5.0, changelog @uiloos/core 1.5.0"
---

<section class="max-w-6xl mx-auto px-5 sm:px-6 my-8">
  <a
    class="inline-flex items-center text-base text-purple-600 hover:underline mb-4"
    href="/releases/core/"
  >
    <svg
      class="w-3 h-3 fill-current text-purple-400 shrink-0 mr-2"
      viewBox="0 0 12 12"
      xmlns="http://www.w3.org/2000/svg"
    >
      <path
        d="M.293 5.282L5 .5l1.414 1.436-3 3.048H12v2.032H3.414l3 3.048L5 11.5.293 6.718a1.027 1.027 0 010-1.436z"
/>
    </svg>
    @uiloos/core releases
  </a>

  <!-- Title -->
  <h1>@uiloos/core 1.5.0</h1>

  <p>Released on <span class="font-mono">TBA</span></p>
</section>

<section class="max-w-6xl mx-auto px-5 sm:px-6 my-8">
  <article class="mb-8">
    <h2>Features</h2>
    <ol class="list-decimal ml-8">
      <li>
        <p>
          It is now easier to use "uiloos" with vanilla JavaScript or TypeScript.
        </p>

        <p>
          As you know when not using a reactive framework such as React or Svelte 
          you manually have to sync the changes with the DOM. To make this easier
          and with less code: this release introduces a new concept: a subscriber creator function. 
          These functions create subscribers for you, which have an easier to use method based API.
        </p>

        <p><strong>What they do is convert events to method calls.</strong></p>

        <p>
          This allows you to write considerably less code because you no longer need 
          to write a lot of if-statements, or one giant switch statements to determine which 
          event took place.
        </p>

        <p>
          For example before 1.5.0 you would write:
        </p>

        <div class="w-full">
{% highlight "javascript" %}
function subscriber(carousel, event) {
  // Start the progress animation
  if (event.type === 'INITIALIZED') {
    // Code here
  }

  // Halt the animation when paused
  if (event.type === 'AUTO_PLAY_PAUSED') {
    // Code here
  }

  // and resume when playing
  if (event.type === 'AUTO_PLAY_PLAYING') {
    // Code here
  }

  // Remove the progress indicator now that the user has
  // assumed full control over the carousel.
  if (event.type === 'AUTO_PLAY_STOPPED') {
    // Code here
  }

  if (event.type === 'ACTIVATED') {
    // Code here
  }
}
{% endhighlight %}
        </div>

        <p>
          And now you can write it like this:
        </p>

        <div class="w-full">
{% highlight "javascript" %}
const subscriber = createActiveListSubscriber({
  onInitialized(event, carousel) {
    // Start the progress animation
    // Code here
  },

  onAutoPlayPaused(event, carousel) {
    // Halt the animation when paused
    // Code here
  },

  onAutoPlayPlaying(event, carousel) {
    // Resume the animation when playing
    // Code here
  },

  onAutoPlayStopped(event, carousel) {
    // Remove the progress indicator now that the user has
    // assumed full control over the carousel.
    // Code here
  },

  onActivated(event, carousel) {
     // Code here
  }
});
{% endhighlight %}
        </div>

        <p>
          You should use a subscriber creator whenever you find that you 
          are creating / need to handle a lot of events from the components.
          Where each event is handled separately and in isolation, and 
          where each event is updating the DOM with laser precision.
        </p>

        <p>
          When your subscriber nukes the DOM by clearing it and rebuilds
          the DOM from scratch, in JavaScript / TypeScript, and on each event. 
          It is easier to use the single (old) subscriber approach.
        </p>
        
        <p>
          Each component now has a subscriber creator function:

          <ol class="ml-16">
            <li>
              A. The ActiveList has the <a href="/api/core/createactivelistsubscriber/" class="underline high">createActiveListSubscriber</a> function.
            </li>

            <li>
              B.  The ViewChannel has the <a href="/api/core/createviewchannelsubscriber/" class="underline high">createViewChannelSubscriber</a> function.
            </li>

            <li>
              C.  The Typewriter has the <a href="/api/core/createtypewritersubscriber/" class="underline high">createTypewriterSubscriber</a> function.
            </li>
          </ol>
        </p>        
      </li>

      <li>
        <p>
          <a href="/api/core/activelist/" class="underline high">ActiveList</a>
          now knows which item was deactivated the last.
        </p>

        <p>
          This is useful when you want to animate the exit of an content within 
          the ActiveList. Say for example that you have a carrousel and only 
          one item it shown at a time, you can animate the last deactivated item
          out of the screen, and the last activated item onto the screen.
        </p>

        <p>
          This is tracked in three new variables:

          <ol class="ml-16">
            <li>
              A. <a href="/api/core/activelist/#lastdeactivated" class="underline high">lastDeactivated</a>:
              which value was the last value to be deactivated.
            </li>

            <li>
              B. <a href="/api/core/activelist/#lastdeactivatedcontent" class="underline high">lastDeactivatedContent</a>:
              which <a href="/api/core/activelistcontent/" class="underline high">ActiveListContent</a> was the last to be deactivated.
            </li>

            <li>
              C. <a href="/api/core/activelist/#lastdeactivatedindex" class="underline high">lastDeactivatedIndex</a>: 
              the index which was last deactivated.
            </li>
          </ol>
        </p>
      </li>

      <li>
        <p>
          All components now have an <a href="/api/core/activelist/#unsubscribeall" class="underline high">unsubscribeAll</a>
          method which unsubscribes all subscribers at once.
        </p>

        <p>
          This is most useful when using <span class="high">uiloos/core</span> directly:
          it allows all the subscribers to be cleared when you know a component is no longer used.
        </p>
      </li>
    </ol>
  </article>

  <article class="mb-8">
    <h2>Fixes</h2>
    
    <ol class="list-decimal ml-8">
      <li>
        <p>
          The <a href="/api/core/activelist/#activatebypredicate" class="underline high">activateByPredicate</a> and 
          <a href="/api/core/activelist/#deactivatebypredicate" class="underline high">deactivateByPredicate</a> both
          always fired the <a href="/api/core/activelistactivatedmultipleevent/" class="underline high">ActiveListActivatedMultipleEvent</a> 
          even when nothing changed.
        </p>

        <p>
          For example: in an ActiveList in which all items are active, when calling <a href="/api/core/activelist/#activatebypredicate" class="underline high">activateByPredicate</a>
          and all items match the predicate: nothing really changes since all items are already active, and in this case no event should be fired.
        </p>

        <p>
          In 1.5.0 checks are put in place to make sure not event is fired when nothing has changed. This way
          subscribers are only informed when there are changes.
        </p>

        <p>
          This only affected you if you used either <a href="/api/core/activelist/#activatebypredicate" class="underline high">activateByPredicate</a> or 
          <a href="/api/core/activelist/#deactivatebypredicate" class="underline high">deactivateByPredicate</a>.
        </p>
      </li>

      <li>
        <p>
          The <a href="/api/core/activelist/#activatebyindex" class="underline high">activateByIndex</a> emits an
          <a href="/api/core/activelistactivatedevent/" class="underline high">ActiveListActivatedEvent</a>
          but did not include information about which item was deactivated.
        </p>

        <p>
          A deactivation can occur when the ActiveList's <a class="underline high" href="/api/core/activelist/#maxactivationlimit">maxActivationLimit</a> is set 
          to a number, and the <a class="underline high" href="/api/core/activelist/#maxactivationlimitbehavior">maxActivationLimitBehavior</a>
          is set to <span class="high">"circular"</span>. In this scenario whenever more items are activated than alloted, the first 
          item that was activated gets deactivated, in a first in first out manner.
        </p>

        <p>
          To fix this since this version two new properties are added to the ActiveListActivatedEvent:  
          <a href="/api/core/activelistactivatedevent/#deactivatedvalue" class="underline high">deactivatedValue</a> and
          <a href="/api/core/activelistactivatedevent/#deactivatedindex" class="underline high">deactivatedIndex</a>.
        </p>

        <p>
          This only affected you if you used <a href="/api/core/activelist/#activatebypredicate" class="underline high">activateByPredicate</a>, and
           <a class="underline high" href="/api/core/activelist/#maxactivationlimit">maxActivationLimit</a> was set 
          to a number, and the <a class="underline high" href="/api/core/activelist/#maxactivationlimitbehavior">maxActivationLimitBehavior</a>
          was set to <span class="high">"circular"</span>.
        </p>
      </li>

      <li>
        <p>
          The <a href="/api/core/activelist/#activatebypredicate" class="underline high">activateByPredicate</a> emits an
          <a href="/api/core/activelistactivatedmultipleevent/" class="underline high">ActiveListActivatedMultipleEvent</a>
          but did not include information about which items were deactivated.
        </p>

        <p>
          A deactivation can occur when the ActiveList's <a class="underline high" href="/api/core/activelist/#maxactivationlimit">maxActivationLimit</a> is set 
          to a number, and the <a class="underline high" href="/api/core/activelist/#maxactivationlimitbehavior">maxActivationLimitBehavior</a>
          is set to <span class="high">"circular"</span>. In this scenario whenever more items are activated than alloted, the first 
          item that was activated gets deactivated, in a first in first out manner.
        </p>

        <p>
          To fix this since this version two new properties are added to the ActiveListActivatedMultipleEvent:  
          <a href="/api/core/activelistactivatedmultipleevent/#deactivatedvalues" class="underline high">deactivatedValues</a> and
          <a href="/api/core/activelistactivatedmultipleevent/#deactivatedindexes" class="underline high">deactivatedIndexes</a>.
        </p>

        <p>
          This only affected you if you used <a href="/api/core/activelist/#activatebypredicate" class="underline high">activateByPredicate</a>, and
           <a class="underline high" href="/api/core/activelist/#maxactivationlimit">maxActivationLimit</a> was set 
          to a number, and the <a class="underline high" href="/api/core/activelist/#maxactivationlimitbehavior">maxActivationLimitBehavior</a>
          was set to <span class="high">"circular"</span>.
        </p>
      </li>

      <li>
        <p>
          The <a href="/api/core/activelist/#activatebypredicate" class="underline high">activateByPredicate</a>
          would not send out an <a href="/api/core/activelistactivatedmultipleevent/" class="underline high">ActiveListActivatedMultipleEvent</a>
          when an <a class="underline high" href="/api/core/activelistactivationlimitreachederror/">ActiveListActivationLimitReachedError</a> was thrown.
        </p>

        <p>
          The error can be thrown when the ActiveList's <a class="underline high" href="/api/core/activelist/#maxactivationlimit">maxActivationLimit</a> is set 
          to a number, and the <a class="underline high" href="/api/core/activelist/#maxactivationlimitbehavior">maxActivationLimitBehavior</a>
          is set to <span class="high">"error"</span>. When more that the alloted items are activated the error is thrown.
        </p>

        <p>
          But when the error occurs it should still report the changes it has made thus far, otherwise 
          the subscribers are never informed of the changes, and they keep displaying stale data.
        </p>

        <p>
          In this version the error is caught, then the event is emitted and then the error is re-thrown.
        </p>

        <p>
          This only affected you if you used <a href="/api/core/activelist/#activatebypredicate" class="underline high">activateByPredicate</a>, and
           <a class="underline high" href="/api/core/activelist/#maxactivationlimit">maxActivationLimit</a> was set 
          to a number, and the <a class="underline high" href="/api/core/activelist/#maxactivationlimitbehavior">maxActivationLimitBehavior</a>
          was set to <span class="high">"error"</span>.
        </p>
      </li>
      
    </ol>
  </article>

  <a class="underline high" href=""></a>
</section>